I'm not sure what inspired me to write an <a href="http://en.wikipedia.org/wiki/Ios">iOS</a> game.  I make giant business software for a living and I hadn't programmed much for Mac before.  But I love games and I'm a giant math nerd so I started with a <a href="http://en.wikipedia.org/wiki/Seven_Bridges_of_K%C3%B6nigsberg">famous math problem</a> called The Seven Bridges of Königsberg.  I also made it <a href="https://github.com/zgrossbart/bridges">open source</a>.

This article is the first in a series that will walk through the game.  You'll find out how it works, what went into designing it, and what you'll need to know to write your own game for iOS.  

<h3>First steps</h3>

There's a few things you'll need to start using the code in this article.  

<ol>
    <li>A mac.</li>
    <li>Xcode.  Get it <a href="https://developer.apple.com/xcode/">free from Apple</a>
</ol>

After you have your computer set up go ahead and <a href="https://github.com/zgrossbart/bridges">download the project from GitHub</a>, open it, and run it.

    <!-- picture of running the app goes here -->
    
That will open the game in the simulator so you can play around with it.

<h3>The Seven Bridges of Königsberg</h3>

Seven bridges is a simple puzzle game.  The player sits in a town of islands surrounded by rivers.  The islands connect with bridges and player must cross each bridges once and only once to with the level.  

    <!-- There should be short video of the game here -->
    
The entire game interaction works with a single gesture:  tap where you want the player to go.  If you hit a bridge you cross it and if you hit a river you bounce off of it.  The game screen also uses buttons to restart the level, undo your last move, and go back to the menu.  There are also houses, subways, and tolls, but we'll get to those later.

Supporting the game screen are a start screen, a menu and a "you won" screen.  

    <!-- Pictures of the three other screens go here    -->
    
This storyboard layout is very common with iOS games.  You'll see the same layout in popular games like <a href="http://en.wikipedia.org/wiki/Cut_the_Rope">Cut the Rope</a> and <a href="http://en.wikipedia.org/wiki/Where's_My_Water%3F">Where's my water</a>.  

<h3>The Minimum</h3>

Seven Bridges is a simple game.  It doesn't handle complex physics like <a href="http://en.wikipedia.org/wiki/Angry_birds">Angry Birds</a> or complex textures like <a href="http://en.wikipedia.org/wiki/Infinity_Blade">Infinity Blade</a>.  Seven Bridges just has a single player who walks over bridges and bumps into rivers.  It sounds easy, but a lot goes into even a simple game like this.

Seven Bridges is written in a combination of <a href="http://en.wikipedia.org/wiki/Objective-C">Objective-C</a> and <a href="http://en.wikipedia.org/wiki/Objective-C#Objective-C.2B.2B">Objective-C++</a>.  If you're used to programming in scripting languages like JavaScript then Objective-C will come as a shock.

<h4>Programming for iOS</h4>

Many people pick up JavaScript by trial and error.  Writing a little jQuery code behind a button is pretty easy in an HTML page.  There are many iOS programming tutorials that make it sound just as easy to write iPhone applications.  That's just not true.

Objective-C has been around for nearly 30 years.  Programming with it means learning a complex environment and some fundamental concepts of how it all holds together.  All of the Objective-C documentation assumes you have a strong background in <a href="http://en.wikipedia.org/wiki/Object-oriented_programming">object-oriented programming</a> and <a href="http://en.wikipedia.org/wiki/C_(programming_language)">the C programming language</a>.

Objective-C shouldn't be your first language or you second.  You should at least make sure that you've read a book about object-oriented programming like <a href="http://www.informit.com/store/product.aspx?isbn=020189551X">Object-Oriented Analysis and Design with Applications</a> by Grady Booch and <a href="http://en.wikipedia.org/wiki/The_C_Programming_Language_(book)">The C Programming Language</a> by Brian Kernighan and Dennis Ritchie.  It's also a good idea to read <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjectiveC/ObjC.pdf">The Objective-C Programming Language</a> from Apple.

<h4>The Files</h4>

This article will look at a little code, so let's start by knowing what we're looking at.  You can tell what each file does by looking at it's file extension.

<ul>
    <li><code>.h</code> files are class <a href="http://en.wikipedia.org/wiki/Header_file">headers</a>.  Each of these files represents the public information available about a single class in the project.</li>
    <li><code>.m</code> files are Objective-C implementation files.</li>
    <li><code>.mm</code> files are Objective-C++ implementation files.  Objective-C is a hybrid where you can use parts of Objective-C and <a href="http://en.wikipedia.org/wiki/C%2B%2B">C++</a> in the same file.  Seven bridges uses Objective-C++ so it can take advantage of frameworks written in C++.</li>
    <li><code>.xib</code> files define visual <code>views</code> in the game where you can layout buttons and other controls.</li>
    <li><code>.png</code> files are individual images used in the game.</li>
    <li><code>.plist</code> files are XML properties files.  They define basics of how the applications work and the positions of the images in each sprite sheet.</li>
    <li><code>.pvr.gz</code> files contain large sets of images combined together into a single file so they load faster and take up less space.</li>
</ul>

Xcode projects also include a folder called <code>your project.xcodeproj</code> containing all of the project configuration files.  Mine is called bridges2 because I messed up the first project so badly I had to start over again.

In addition to the basics of Objective-C there's decades of patterns and other frameworks to learn.

<h3>The Frameworks</h3>

Seven Bridges uses two major frameworks in addition to the basic user interface framework from Apple called UIKit.

<h4>UIKit</h4>

Every iOS application starts with <a href="http://developer.apple.com/library/ios/#documentation/uikit/reference/UIKit_Framework/_index.html">UIKit</a>.  This comprehensive framework from Apple provides all of the basic controls your application uses like Windows, Buttons and TextFields.  Most of the classes in UIKit start with the prefix <code>UI</code> like UIWindow or UIButton.  

The easiest way to work with UIKit is the visual view editor provided in the <a href="http://en.wikipedia.org/wiki/Xcode">Xcode</a> from Apple.  XCode makes it easy to drag and drop control into your application, but it doesn't really cover games.  Xcode doesn't know anything about a river or a bridge in my game.  For that I'll need a gaming framework and a bit of code.

<h4>Cocos2d</h4>

UIKit provides buttons and labels, but not the more complex controls a game uses.  You could draw on the screen directly with <a href="http://en.wikipedia.org/wiki/Opengl">OpenGL</a>, but that means doing a lot of work to manage each pixel on the screen.  Game libraries provide higher level support for placing images, moving them around, and managing your game.  There are a few for iOS.

I chose <a href="http://www.cocos2d-iphone.org/">Cocos2d for iPhone</a> because it's well supported, has a simple API, and comes with a lot of examples.  It also has <a href="http://www.raywenderlich.com/">Ray Wenderlich's</a> excellent tutorials.

Ray is a prolific writer about iOS games.  Every time I searched for a new topic it invariably led back to him.  His <a href="http://www.raywenderlich.com/606/how-to-use-box2d-for-just-collision-detection-with-cocos2d-iphone">tutorial about collision detection</a> provided the fundamentals for my game.

Cocos2d handles all of the <a href="http://en.wikipedia.org/wiki/Sprite_(computer_graphics)">sprites</a> in my game, the scenes where you're actually playing, and the animations.  Cocos2d files start with the prefix <pre>CC</pre> It was origionally written in Python so make sure you search for Cocos2d iPhone when you're looking for help.

Cocos2d handles interacticing with the user, but it can't handle interactions with the objects.  I need to know when my player runs into a river, bridge or any other object.  That type of collision detection requires Box2d.

<h4>Box2d</h4>

<a href="http://en.wikipedia.org/wiki/Box2d">Box2d</a> is a <a href="http://en.wikipedia.org/wiki/Physics_engine">physics engine</a> written in portable C++.  It can handle complex concepts like gravity and friction, but we're only using it for collision detection.  Box2d files start with the prefix <pre>b2</pre>.

My game doesn't use the complex physics of swining candy from Cut the Rope or sloshing liquids from Where's My Water.  It just handles a player walking around the screen and bumping into things.  Box2d tells me when those bumps happen and I handle the rest.

    <!-- picture of a tap and a bump should go here -->
    
These three frameworks come together to build the game scene.

<h3>Building a scene</h3>

The playable area of the game is drawn with <a href="https://github.com/zgrossbart/bridges/blob/master/bridges2/LevelLayer.mm">LevelLayer</a> which extends the Cocos2d class <code>CCLayerColor</code>.  This layer handles drawing everything in the game and responding to the player interactions.  

The game is made up of a set of images called sprites.  Each item on the game scene like a bridge or a piece of a river is made up of a sprite.
  
    <!-- diagram of scene pieces goes here -->
    
The sprites all fit together into a single image called a sprite sheet.  Cocos2d can take that image and a proerties file of coordinates and create the individual images from it.  

The real reason to use a sprite sheet is performance.  Ray Wenderlich wrote a good <a href="http://www.raywenderlich.com/2361/how-to-create-and-optimize-sprite-sheets-in-cocos2d-with-texture-packer-and-pixel-formats">article comparing sprite sheet performance with individual images</a>, but the short answer is that sprite sheets are a lot faster.

Managing sprite sheets manually is a real pain, so I used <a href="http://www.codeandweb.com/texturepacker">TexturePacker</a>.  It's paid software, but $25 is well worth the hours of adjusting pixel coordinates it saved me.  TexturePacker can also convert the sprite sheet to PVR (the internal image format for iOS) and compress it with GZIP.

Once we've created the sprite sheet we're ready to add the sprites to the scene.

<h4>Adding the sprites</h4>

Xcode makes it easy to drag and drop images into a View, but that doesn't work for dynamic scenes like our game levels.  We'll need to write some code.

Cocos2d interprets our sprite sheet with the <code>CCSpriteBatchNode</code> class.  We initialize the sprite sheet once for the application and then use the individual items when we build our level.

<pre class="brush: objective-c">
CCSpriteBatchNode *spriteSheet = [[CCSpriteBatchNode batchNodeWithFile:@"bridgesprites.pvr.gz"
                                 capacity:150] retain];
[[CCSpriteFrameCache sharedSpriteFrameCache]
addSpriteFramesWithFile:@"bridgesprites.plist"];
[self addChild:_spriteSheet];
</pre>

This code creates a new sprite sheet with our sprites file, initializes it with the properties file defining the images in the sheet, and adds the sheet as a child to our current scene.

Now that we have the sheet we can use it to load individual sprites like this:

<pre class="brush: objective-c">CCSprite *bridge = [CCSprite spriteWithSpriteFrameName:[self @"bridge_v.png"]];
[spriteSheet addChild:bridge];
bridge.position = ccp(100, 100);
</pre>

This code snippet creates a new sprite from the sprite sheet, adds that sprite as a child of the sheet, and positions it 100 points from the left side of the screen and 100 points up from the bottom.  

UIKit puts the point 0,0 at the top left of the screen.  Cocos2d puts 0,0 in the bottom left.  
  
The game positions these sprites on the screen using a set of tiles.  

<h4>Pixels, Points and Tiles</h4>

iOS supports five different devices:  iPhone 3.5 inch, iPhone 3.5 inch retina, iPhone 4 inch retina, iPad and iPad retina.  

    <!-- diagram comparing device sizes goes here -->
    
Supporting every device means handling multiple layouts.  Cocos2d gives you a lot of help here by supporting points instead of pixels when specifying layout.  Pixels represent an exact screen location where points are relative to the device.  

Seven Bridges goes farther by defining a tile system.  Tiles are a way of grouping pixels into larger squares for easier layout.  We make the screen 28 tiles tall and at least 42 tiles wide.  The tiles make it easy to define where the sprites go on each level.

    <!-- debug drag image goes here -->
    
<h4>Touches and interactions</h4>

UIKit handles touches on controls like buttons, but for the game scene we need a generic touch handler.  Cocos2d provides that with the <code>touchesEnd</code> method.  First we have to tell Cocos2d that we want touch events like this:

<pre class="brush: objective-c">self.isTouchEnabled = YES;
</pre>

The we implement the <code>touchesEnded</code> method to get called whenever the user taps the screen.

<pre class="brush: objective-c">-(void)ccTouchesEnded:(NSSet*) touches withEvent:(UIEvent*) event {
   UITouch *touch = [touches anyObject];
   CGPoint location = [touch locationInView:[touch view]];
   location = [[CCDirector sharedDirector] convertToGL:location];
   
   // Do some stuff with the point the user touched...
}
</pre>

The logic for handling the touch is simple:

<pre>
    If the player isn't on the screen yet then place the player sprite where the user touched and return.
    If the player is on the screen then move the player from the current location to the place where the user touched.
</pre>

That's all we need to do for the touch.  The real logic of the game happens when we handle the collisions.

<h4>Boxes and collisions</h4>

Each object on the screen is a sprite; just a little image file that sits at a specific screen coordinate.  Cocos2d can handle positioning and animating those images, but it doesn't know if they run into each other.  This is where Box2d shines.    

The <a href="https://github.com/zgrossbart/bridges/blob/master/bridges2/LayerMgr.mm">LayerMgr</a> class manages adding and removing all of the images from the layers in the game.  When it adds an image it also draws a box around it.  

Boxes are the fundamental concept of Box2d.  They outline the position of an object on the screen and detect when it interacts with other objects.  Box2d supports complex box shapes, but all the boxes in this game are rectangles.

Whenever we add an image to the scene we draw a box around it with Box2d.  The box works with a helper class called a <a href="https://github.com/zgrossbart/bridges/blob/master/bridges2/MyContactListener.h">contact listener</a>.  This listener sits in a timer and asks the Box2d model if any of the objects have run into each other after each frame of the game.  

When two boxes run into each other we have contact and need to react to it.  The logic for contacts is also simple:

<pre>
    If the player contacts a river then bounce back.
    If the player contacts a bridge then check if the bridge has been crossed.
        If the bridge is crossed then bounce back.
        If the bridge isn't crossed them cross it and move the player to the other side.
</pre>

Separating the player movement from the collision makes it easy to move the player around the screen.  We don't have to define islands or work with any higher level concepts.  Instead we just define the position of each piece in a level file.

<h3>Defining levels</h3>

Each level of the game is defined in a separate JSON document.  It's important to separate the level definitions from the code so you can update the levels or add new ones without changing the code.

Each level defines a name, an ID and a set of objects that go in the level.

<pre class="brush: javascript">{
    "level": {
        "id": "1",
        "name": "Hello Bridges!",
        "rivers": [
            {
                "x": "14",
                "y": "b-t",
                "orient": "v"
            }
        ],
        "bridges": [
            {
                "x": "14",
                "y": "m",
                "orient": "h"
            }
        ]
    }
}
</pre>

Each object has a coordinate in the tile system and a set of properties defining how the object works.  For example, a bridge specified an <code>orient</code> property to know if it's a horizontal or vertical bridge and a <code>color</code> property to know if the bridge has a specific color.  

Many games define levels as XML, but I chose JSON because it's faster to parse and works better with the web.  One day I'd like to create a mode where you can load new levels from a website without updating the game.

Loading each level takes a <a href="https://github.com/zgrossbart/bridges/blob/master/bridges2/Level.h">Level</a> class and they're controlled by a <a href="https://github.com/zgrossbart/bridges/blob/master/bridges2/LevelMgr.h">LevelMgr</a>.  

Seven Bridges does a lot more, but this is a good place to stop for the first article.

<h3>What's next</h3>

This article provides an introduction to some of the pieces of this game.  There are many more.  I'd like to hear from you about what should come next.  Here are a few ideas:

<ul>
    <li>iOS game design fundamentals</li>
    <li>iOS graphics and graphic formats</li>
    <li>Loading levels and parsing JSON with Objective-C</li>
    <li>Handling player movements and animations</li>
    <li>Creating level screenshots and handling menus</li>
    <li>Developing for iPhone and iPad</li>
    <li>Objective-C language fundamentals</li>
</ul>

There are a lot of directions we could go.  What's helpful for you?  Leave a comment and let us know which article should come next in this series.
