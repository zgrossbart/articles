Strongly typed languages are the best because they keep you out of trouble.  Weakly typed languages are the best because they get out of your way and let you get your work done faster.  The debate between strongly and weakly typed languages rages on, but understanding the issue starts with <a href="http://en.wikipedia.org/wiki/C_(programming_language)">C</a>.

C treats everything like a number in memory.  A character is just the number representing it and true and false are just 1 and 0.  

C defines variables with types like <code>int</code> for integer or <code>char</code> for character, but that just defines how much memory to use.  When I want to access the variable and print it out I need to know the type.

<pre class="brush: javascript"> int a = 1;
printf("The number is %i\n", a);

char z = 'z';
printf("The character is %c\n", z);
</pre>

When I run this program it shows:

<pre>The number is 1
The character is z
</pre>

The <code>printf</code> function needs a hint from us to know how to format the variable.  If I give the wrong hint 

<pre class="brush: javascript">char z = 'z';
printf("The character is %i\n", z);
</pre>

I get

<pre>The character is 122
</pre>

C doesn't know if <code>z</code> is a character or an integer, it has a weak type.

Weak typing is fast since there's no overhead of remembering the different types, but it leads to some nasty bugs.  There's no way to format the <code>z</code> to if you don't know it's type ahead of time.  Imagine you access a variable and get the number <code>1229799107</code>.  The number could be the result of a mathematical calculation (1,229,799,107), the cost of a government program ($1.2 billion) or a time stamp (Saturday, 20 Dec 2008).  When all you have is the number there's no way to know that it's really the number codes for the letters in my name: <code>zack</code>.

Confusion over types gets worse with larger projects.  The code's impossible to follow or debug without a lot of documentation.  The frustration over these issues inspired strong typing.

<h3>Mostly strong languages - C++ and Objective-C</h3>

The next programing languages used a subset of the C functionality and strict guidelines to improve the loose nature of the language.  <a href="http://en.wikipedia.org/wiki/C%2B%2B">C++</a> and <a href="http://en.wikipedia.org/wiki/Objective-C">Objective-C</a> compile into the same bytes as C, but they use the compiler to restrict the code you can write.  

In C++ and Objective-C our number (1229799107) has a meaning.  I can define it as a string of characters and make sure that nobody tries to use it as a currency or a date.  The compiler enforces that it's used properly, but 

Static typing supports objects with sets of functionality that always work in a well defined way.  Now I can create a <code>Person</code> object and make sure the <code>getName</code> function always returns the string of someone's name.

<pre class="brush: javascript">class Person {
    public:
        string getName() {
            return "zack";
        }
};
</pre>

Now I can call my object like this:

<pre class="brush: javascript">Person p;
printf("The name is %s\n", p.getName().c_str());
</pre>

Static typing goes a long way to avoid the bugs from weakly typed languages, but it can't check anything when the program is running since a C++ or Objective-C program is just like C code when it runs.  They also left the option of mixing weakly typed C code with static typed C++ or Objective-C to bypass all of the type checking.
  
Java went a step beyond that to add type checking when the code runs.

<h3>Completely strong languages - Java</h3>

C++ offers you some stricter ways of using C, Java makes sure you use them.  Java needs everything defined so you know at all times what type of object you have, which functions that object has and if you're calling them properly. 

Java also stopped supporting C code and the other ways of getting out of strong typing.

The <code>Person</code> object looks almost the same in Java.

<pre class="brush: javascript">public class Person {
    public String getName() {
        return "zack";
    }
}
</pre>

I get the name by creating a new object and calling the <code>getName</code> function like this:

<pre class="brush: javascript">public class Main {
    public static void main (String args[]) {
        Person person = new Person();
        System.out.println("The name is " + person.getName());
    }
}
</pre>

This code creates a new <code>Person</code> object, assigns it to a variable named <code>person</code>, calls the <code>getName</code> function and prints out the value.  I don't need a formatter string like <code>%s</code> because Java gave everything a <code>toString</code> function.  

If I try to assign my <code>person</code> variable to a different type like a character or an integer the Java compiler will show an error that these are incompatible types.  If I was calling a separate API which had changed since I compiled the Java runtime would still find the type error.  

Java also puts every piece of code in an object.  It's a big part of the reason why people complain Java forces you to write too much boiler plate.

The popularity of Java and its strong adherence to strong typing made a huge impact on the programming landscape.  Strong typing advocates lauded Java for fixing the cracks in C++, but many programmers found Java overly prescriptive and rigid.  They wanted a fast way to write code without all of the extra definition of Java.

<h3>Dynamically typed languages - JavaScript, Python, Ruby, PHP and many more</h3>

Weakly typed languages don't do any type checking, strongly typed languages always do, dynamic languages split the difference.  In JavaScript I define a variable with the keyword <code>var</code> instead of a type like <code>int</code>, or <code>char</code>.  I don't know the type of this variable and I don't need to until I actually want to access it.

I can define an object in JavaScript with the <code>getName</code> function.

<pre class="brush: javascript">var person = {
    getName: function() {
        return 'zack';
    }
};

alert('The name is ' + person.getName());
</pre>

Now I have an object named assigned to the variable <code>person</code> and it has a function named <code>getName</code>.  If I call <code>person.getName()</code> it will result in <code>zack</code>.  

I declared <code>person</code> as a <code>var</code> and I can reassign it to anything.  It's variable.

<pre class="brush: javascript">var person = {
    getName: function() {
        return 'zack';
    }
};

person = 5;

alert('The name is ' + person.getName());
</pre>

This code creates a variable name <code>person</code> and assigns it to an object with a <code>getPerson</code> function, but then it reassigns that variable to the number 5.  When this code runs the result is <code>TypeError: Object 5 has no method 'getName'</code>.  JavaScript says that the object <code>5</code> doesn't have a function named <code>getName</code>.  In Java this error would come up during compilation, but JavaScript makes you wait for runtime.  

I can also change the type of the object based on the conditions of the program.  Java would call this a type error, but it's fine in JavaScript:

<pre class="brush: javascript">var person = {
    getName: function() {
        return 'zack';
    }
};

if (new Date().getMinutes() &gt; 29) {
    person = 5;
}

alert('The name is ' + person.getName());
</pre>

Now this code will work at 9:15, but will fail at 9:30.  

Dynamic typing is often called duck typing because the code looks at the object during runtime to determine the type and if it walks like a duck and quacks like a duck then it must be a duck.  

Duck typing means you can redefine any object in the middle of the program.  It can start as a duck and turn into a swan or goose.

<pre class="brush: javascript">var person = {
    getName: function() {
        return 'zack';
    }
};

person['getBirthday'] = function() {
    return 'July 18th';
};

alert('The name is ' + person.getName() + ' and the birthday is ' + person.getBirthday());
</pre>

At any point I can change the nature of my <code>person</code> object to add new the new <code>getBirthday</code> function or remove existing functionality.  Java won't allow that because you can't check object types when they're always changing.  Dynamically redefining objects gives you a lot of power for good and bad.

C shows errors when the program runs.  C++, Objective-C and Java use the compiler to catch errors at compile time.  JavaScript pushed those errors back to the run time of the application.  That's why the strongly typed people hate JavaScript so much.  It looks like a big step backward.

<h3>Weakly typed is the best until it isn't</h3>

I recently needed a program to find a place in a specific XML file, make a small change and save the file.  On a team of Java coders I wrote the code in the dynamically typed language Python.  

<pre class="brush: python">import sys
import string
from xml.dom.minidom import parse

dom = parse(sys.argv[1])

for node in dom.getElementsByTagName('property'):
    attr = node.attributes['name'];
    if attr.value == 'my value':
        node.childNodes[0] = dom.createTextNode('my new value');

file = open(sys.argv[1], 'w');
file.write(dom.toxml('UTF-8'));
file.close();
</pre>

This program finds every property node with the name <code>my value</code> and sets the contents to <code>my new value</code>.  I define the variables <code>dom</code> for my XML document, <code>node</code> for the each node of XML I find and <code>attr</code> for the attribute.  Python doesn't even require the keyword <code>var</code> ad it doesn't know that <code>node</code> has <code>childNodes</code> or <code>attr</code> has <code>value</code> until I call it.

To change an XML file in Java I would write a new class, open an input stream, call the DOM parser, traverse the tree, call the right methods on the right elements, and write the file out to an output stream.  All of the extra definition of objects and variables could easily take a hundred lines.  Python took 14.

Dynamic code is generally shorter than static code because it needs less description of what the code is going to do.  This program would be shorter in PHP than C++ or in Ruby than Objective-C.  

Fewer lines of code means less bugs, but there's a trade off.  The bugs in dynamic languages come at runtime and kill my application in production.  I can test before I deploy, but I'll never find the bug that only happens at three in the morning until it happens.  

Coding strongly typed languages takes more time, but they find more bugs before they happen.  The compiler makes sure every variable and function call is accessed correctly.  Smaller projects don't have these issues, but every large project does.

Dynamic language projects can't grow past a certain size without process to keep them in control.  Some teams require extra comments and others use additional tools to restrict the language and avoid type errors.  These processes all take on pieces of the strongly typed philosophy, but programmers debate endlessly about how much.

C programmers spent years tearing their hair out over type conversion errors, corrupt values, and the terrible bugs that come from small typos.  They've been burnt and learned that the compiler helps them stay out of trouble.  The more complex the software the more trouble it causes.

Dynamic language advocates say you can write code faster, fix the bugs and save time overall.  Dynamic languages win for smaller programs like the XML file writer.  Larger project like <a href="http://en.wikipedia.org/wiki/Photoshop">Photoshop</a>, <a href="http://en.wikipedia.org/wiki/Oracle_Database">big databases</a> and <a href="http://en.wikipedia.org/wiki/Google_Chrome">web browsers</a> overwhelmingly code with strongly typed languages.  And there's a big gray area in between.

Strongly typed languages make the program more difficult to write, but easier to maintain.  Dynamic languages are easy to write, but cost more in maintenance.  It's all about where you want to spend your time.
