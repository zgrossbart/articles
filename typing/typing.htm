Strongly typed languages are the best because they keep you out of trouble.  Weakly typed languages are the best because they get out of your way and let you get your work done faster.  The debate between strongly and weakly typed languages rages on, but understanding the issue starts with <a href="http://en.wikipedia.org/wiki/C_(programming_language)">C</a>.

C treats everything like a number in memory.  A character is just the number representing it and true and false are just 1 and 0.  

C defines variables with types like <code>int</code> for integer or <code>char</code> for character, but that just defines how much memory to use.  When I want to access the variable and print it out I need to know the type.

<pre class="brush: javascript"> int a = 1;
printf("The number is %i\n", a);

char z = 'z';
printf("The character is %c\n", z);
</pre>

When I run this program it shows:

<pre>The number is 1
The character is z
</pre>

The <code>printf</code> function needs a hint from us to know how to format the variable.  If I give the wrong hint 

<pre class="brush: javascript">char z = 'z';
printf("The character is %i\n", z);
</pre>

I get

<pre>The character is 122
</pre>

C doesn't know if <code>z</code> is a character or an integer, it has a weak type.

Weak typing is fast since there's no overhead of remembering the different types, but it leads to some nasty bugs.  There's no way to format the <code>z</code> to if you don't know it's type ahead of time.  Imagine you access a variable and get the number <code>1229799107</code>.  The number could be the result of a mathematical calculation (1,229,799,107), the cost of a government program ($1.2 billion) or a date (Saturday, 20 Dec 2008).  When all you have is the number there's no way to know that it's really the codes for the letters in my name: <code>zack</code>.

Confusion over types gets worse with larger projects.  The code's impossible to follow or debug without a lot of documentation.  The frustration over these issues inspired strong typing.

<h3>Mostly strong languages - C++ and Objective-C</h3>

The next programing languages used a subset of the C functionality and strict guidelines to improve the loose nature of the language.  <a href="http://en.wikipedia.org/wiki/C%2B%2B">C++</a> and <a href="http://en.wikipedia.org/wiki/Objective-C">Objective-C</a> compile into the same bytes as C, but they use the compiler to restrict the code you can write.  

In C++ and Objective-C our number (1229799107) has a meaning.  I can define it as a string of characters and make sure that nobody tries to use it as a currency or a date.  The compiler enforces that it's used properly, but 

Static typing supports objects with sets of functionality that always work in a well defined way.  Now I can create a <code>Person</code> object and make sure the <code>getName</code> function always returns the string of someone's name.

<pre class="brush: javascript">class Person {
    public:
        string getName() {
            return "zack";
        }
};
</pre>

Now I can call my object like this:

<pre class="brush: javascript">Person p;
printf("The name is %s\n", p.getName().c_str());
</pre>

Static typing goes a long way to avoid the bugs from weakly typed languages, but it can't check anything when the program is running since a C++ or Objective-C program is just like C code when it runs.  They also left the option of mixing weakly typed C code with static typed C++ or Objective-C to bypass all of the type checking.
  
Java went a step beyond that to add type checking when the code runs.

<h3>Completely strong languages - Java</h3>

C++ offers you some stricter ways of using C, Java makes sure you use them.  Java needs everything defined so you know at all times what type of object you have, which functions that object has and if you're calling them properly. 

Java also stopped supporting C code and the other ways of getting out of strong typing.

The <code>Person</code> object looks almost the same in Java.

<pre class="brush: javascript">public class Person {
    public String getName() {
        return "zack";
    }
}
</pre>

I get the name by creating a new object and calling the <code>getName</code> function like this:

<pre class="brush: javascript">public class Main {
    public static void main (String args[]) {
        Person person = new Person();
        System.out.println("The name is " + person.getName());
    }
}
</pre>

This code creates a new <code>Person</code> object, assigns it to a variable named <code>person</code>, calls the <code>getName</code> function and prints out the value.  I don't need a format string like <code>%s</code> because Java gave everything a <code>toString</code> function.  

If I try to assign my <code>person</code> variable to a different type like a character or an integer the Java compiler will show an error that these are incompatible types.  If I was calling a separate API which had changed since I compiled the Java runtime would still find the type error.  

Java also puts every piece of code in an object.  It's a big part of the reason why people complain Java forces you to write too much boiler plate.

The popularity of Java and its strong adherence to strong typing made a huge impact on the programming landscape.  Strong typing advocates lauded Java for fixing the cracks in C++, but many programmers found Java overly prescriptive and rigid.  They wanted a fast way to write code without all of the extra definition of Java.

<h3>Dynamically typed languages - JavaScript, Python, Ruby, PHP and many more</h3>

Weakly typed languages don't do any type checking, strongly typed languages always do, dynamic languages split the difference.  In JavaScript I define a variable with the keyword <code>var</code> instead of a type like <code>int</code>, or <code>char</code>.  I don't know the type of this variable and I don't need to until I actually want to access it.

I can define an object in JavaScript with the <code>getName</code> function.

<pre class="brush: javascript">var person = {
    getName: function() {
        return 'zack';
    }
};

alert('The name is ' + person.getName());
</pre>

Now I have an object named assigned to the variable <code>person</code> and it has a function named <code>getName</code>.  If I call <code>person.getName()</code> it will result in <code>zack</code>.  

I declared <code>person</code> as a <code>var</code> and I can reassign it to anything.  It's variable.

<pre class="brush: javascript">var person = {
    getName: function() {
        return 'zack';
    }
};

person = 5;

alert('The name is ' + person.getName());
</pre>

This code creates a variable name <code>person</code> and assigns it to an object with a <code>getPerson</code> function, but then it reassigns that variable to the number 5.  When this code runs the result is <code>TypeError: Object 5 has no method 'getName'</code>.  JavaScript says that the object <code>5</code> doesn't have a function named <code>getName</code>.  In Java this error would come up during compilation, but JavaScript makes you wait for runtime.  

I can also change the type of the object based on the conditions of the program.  Java would call this a type error, but it's fine in JavaScript:

<pre class="brush: javascript">var person = {
    getName: function() {
        return 'zack';
    }
};

if (new Date().getMinutes() &gt; 29) {
    person = 5;
}

alert('The name is ' + person.getName());
</pre>

Now this code will work at 9:15, but will fail at 9:30.  

Dynamic typing is often called duck typing because the code looks at the object during runtime to determine the type and if it walks like a duck and quacks like a duck then it must be a duck.  

Duck typing means you can redefine any object in the middle of the program.  It can start as a duck and turn into a swan or goose.

<pre class="brush: javascript">var person = {
    getName: function() {
        return 'zack';
    }
};

person['getBirthday'] = function() {
    return 'July 18th';
};

alert('The name is ' + person.getName() + ' ' + 
      'and the birthday is ' + person.getBirthday());
</pre>

At any point I can change the nature of my <code>person</code> object to add new the new <code>getBirthday</code> function or remove existing functionality.  Java won't allow that because you can't check object types when they're always changing.  Dynamically redefining objects gives you a lot of power for good and bad.

C shows errors when the program runs.  C++, Objective-C and Java use the compiler to catch errors at compile time.  JavaScript pushed those errors back to the run time of the application.  That's why the strongly typed people hate JavaScript so much.  It looks like a big step backward.

<h3>Which is better?</h3>

I recently needed a program to find a place in a specific XML file, make a small change and save the file.  On a team of Java coders I wrote the code in the dynamically typed language Python.  

<pre class="brush: python">import sys
import string
from xml.dom.minidom import parse

dom = parse(sys.argv[1])

for node in dom.getElementsByTagName('property'):
    attr = node.attributes['name'];
    if attr.value == 'my value':
        node.childNodes[0] = dom.createTextNode('my new value');

file = open(sys.argv[1], 'w');
file.write(dom.toxml('UTF-8'));
file.close();
</pre>

This program finds every property node with the name <code>my value</code> and sets the contents to <code>my new value</code>.  I define the variables <code>dom</code> for my XML document, <code>node</code> for the each node of XML I find and <code>attr</code> for the attribute.  Python doesn't even require the keyword <code>var</code> ad it doesn't know that <code>node</code> has <code>childNodes</code> or <code>attr</code> has <code>value</code> until I call it.

To change an XML file in Java I would write a new class, open an input stream, call the DOM parser, traverse the tree, call the right methods on the right elements, and write the file out to an output stream.  All of the extra definition of objects and variables could easily take a hundred lines.  Python took 14.

Dynamic code is generally shorter than static code because it needs less description of what the code is going to do.  This program would be shorter in PHP than C++ or in Ruby than Objective-C.  

So which is better?

<style>
.toc { 
	width: 100%;
margin: 1em 0;
	border: 1px solid rgba(0,0,0,0.1); }
.toc td, .toc th {
	padding: 4px 10px;
	border-bottom: 1px solid #eee;
border-right: 1px solid #eee;
border-collapse: collapse;
text-align: left;
}
.toc th {
background-color: #ECECEC;
}

</style>

<table class="toc">
<tbody>
<tr>
<th>The static programmer says</th>
<th>The dynamic programmer says</th>
</tr>
<tr>
<td>Static typing catches bugs in the compiler and keeps you out of trouble</td>
<td>Static typing only catches some bugs and you can't trust the compiler to do your testing</td>
</tr>
<tr>
<td>Static languages are easier to read because they're more explicit about what the code does</td>
<td>Dynamic languages are easier to read because less code means fewer bugs</td>
</tr>
<tr>
<td>At least I know the code compiles</td>
<td>Just because the code compiles doesn't mean it runs</td>
</tr>
<tr>
<td>I trust the static typing to make sure my team writes good code</td>
<td>The compiler doesn't stop you from writing bad code</td>
</tr>
<tr>
<td>Debugging an unknown object is impossible</td>
<td>Debugging overly complex object hierarchies is unbearable</td>
</tr>
<tr>
<td>Compiler bugs happen in the middle of the morning in my office and, runtime bugs happen at midnight for my customers</td>
<td>There's no replacement for testing and unit tests find more issues than the compiler ever could</td>
</tr>
</tbody>
</table>

Static typing made our <code>Person</code> object easier to understand.  We defined a <code>Person</code> with a name and agreed about which fields mattered ahead of time.  Establishing everything clearly makes our <code>Person</code> easy to debug, but harder to change.  

What happens when someone in our application needs a second email address?  In a static language we need to redefine the object so everyone has two emails even if most people don't.  Add in a birthday, favorite color, and a few more items and every <code>Person</code> has twice as many fields as they really need.

Dynamic languages make this problem much easier.  We can add second email to one <code>Person</code> without adding it to everyone.  Now each object only has the fields it needs.  A static language could handle this with a generic map of values, but then you're fighting the static environment to write dynamic code.

C programmers spent years tearing their hair out over type conversion errors, corrupt values, and the terrible bugs that come from small typos.  They've been burnt by weak typing and dynamic typing looks weak.  

Dynamic programmers spent years banging their heads on the rigidity of static languages and crave the freedom to make the language do what they want.

I've seen static code get overly complex and impossible to follow.  Try debugging an <a href="http://en.wikipedia.org/wiki/Enterprise_JavaBeans">enterprise JavaBean</a> or understanding all the details of <a href="http://en.wikipedia.org/wiki/Generics_in_Java">generics in Java</a>.

I've seen dynamic code turn into giant mounds of unmaintainable spaghetti.  Look at the myriad of terrible JavaScript before jQuery.  <a href="http://en.wikipedia.org/wiki/Node.js">Node.js</a> does some amazing things, but I can't look at it without traumatic flashbacks of horrible JavaScript I've debugged.

There's no clear conclusion.  Dynamically typed languages are popular now.  The pendulum will swing back and forth many times in the coming years.  The only solution is flexibility.  Learn to work in each environment and you'll work well with any team.
