<h1>P vs. NP: The gigantic assumption that runs the Internet<\h1>

You're looking at <em>Smashing Magazine</em> right now because you're standing on the shoulders of a giant assumption called <strong>P vs. NP</strong>. It's a math problem that protects governments, runs the Internet, and makes online shopping possible.

P vs. NP is a math question masquerading as a philosophy one.  It describes the difference between solving a problem and knowing whether you solved it.  Let's start with a simple example called "the traveling salesman problem."

Our salesman is entering a town with houses spread across a number of different streets.  He needs to visit every house once and only once.  He wants to find the fastest route that takes him to every house, but requires as little walking as possible.  

<house map here>

The salesman doesn't know if it's better to go up Main Street first and then turn; to start by turning left; or to walk around the town and start from the other side.  The only way he can know for sure is to try each route and measure how long it takes.  There's no formula he can follow to figure out the fastest route, he just has to find the answer with brute force.  Finding the answer is the "NP" part, which we'll define soon.

Knowing whether he found an answer is easy.  If he visited each house he's done the job; if he skipped one, then he has to start over.  That's the "P" part, which you'll learn about shortly.  All P vs. NP problems are tough to solve, but easy to verify.

<h2>Yeah ... There Are Some Big Words</h2>

The P in P vs. NP stands for "<strong>polynomial</strong> time."  That just means we can predict the maximum amount of time it will take to solve the problem.  The classic example of polynomial time is a quick sort.  Here's a set of blocks:

<messy block picture goes here - messy_blocks.gif>

I want to sort them in order from the shortest to the tallest.  The easiest way to do that is to divide the group in half, pushing the tall blocks to one side and the short blocks to the other side.  Then I cut each half in half, and repeat.  
<http://commons.wikimedia.org/wiki/File:Sorting_quicksort_anim.gif>

There's a simple equation (not important here) which can tell me how long this will take.  It doesn't matter how many blocks I have or how disorganized they are, I can always predict the worst-case scenario for how long it will take to sort any number of blocks.  The predictable part is what makes it polynomial.  All of the common math we use &mdash; addition, algebra, and balancing your checkbook &mdash; can be done in polynomial time.

NP stands for "<strong>nondeterministic polynomial</strong> time."  It's basically the opposite of P:  it means there's no equation or formula to predict how long it will take to solve a problem.  Normally the only way to solve this kind of problem is to keep trying answers until we find one that works.  Figuring out the best route for our salesman is an NP problem, sometimes called "NP-complete."

Let's look at a few routes our salesman could take.  He could start from the bottom and go up first:

<house map route picture 1>

That's about XXX steps.  He could also start by turning right and visiting the houses in the lower left first:

<house map route picture 2>

That one's about XXX steps.  The salesman could also turn the map around and start from the top.  Now he can visit that cul-de-sac easily, but he has to loop back around to get the houses in the bottom left.  That route's about XXX steps.

Though we can measure each route to see which is shortest, there's no way to predict the lengths without trying.  We can make guesses, but pretty soon we just have to start walking.  The traveling salesman problem is famous because visiting every house along the shortest route is NP (very hard), but making sure you've visited every house is P (very easy).

We could solve this map in a few minutes, but every house we add would make the solution take minutes, hours, or even years longer.  

<h2>Why This All Matters</h2>

The traveling salesman is a cute problem, but the implications are giant.  

Change the salesman to a page request, and the houses to servers, and you've got Internet packet routing.  When my computer in Boston wants to send requests to a computer in London, it has to figure out a path to get there.  The data could take thousands of different routes through thousands of different computers.  (That's why Google, Facebook, and Apple build data centers near major cities; they're trying to make the map smaller when people make requests.)

If you could figure out a better way to route data on the Internet, you could make stock trades faster than everyone else and <a href="http://en.wikipedia.org/wiki/Flash_Boys">make billions of dollars</a>.  

Another version of this problem is all about secrets.

Most of the Internet runs on secrets.  I want to give my credit card information to Amazon, but not to the guy sitting next to me at Starbucks.  I don't want to share my bank password with my neighbors, and I don't want to let my frenemies read my email.  You can shop, share, and work on the Internet because of secrets, and all of those secrets are based on math.

Most of the secrets on the Internet are protected by <a href="http://www.smashingmagazine.com/2012/05/17/backpack-algorithms-and-public-key-cryptography-made-easy/">public key cryptography</a>, which depends on finding two large numbers which, multiplied together, equal a very large number.  The two large numbers are <strong>factors</strong> of the very big number.  (Think of a backpack full of weights.  You may know the pack weighs 20 pounds, but you don't know if it has one 20-pound weight, 20 one-pound weights, or anything in between.)

For example, take the number 26.  It has four factors:  1, 2, 13, and 26.  Every number contains 1 and the number itself, so we'll ignore those factors; the important ones are 2 and 13.

<pre>
2 times 13 = 26
</pre>

You can find the factors of 26 by trying every number between one and 26.  It's a lot tougher with a mind-bendingly large number like:

<pre>33478071698956898786044169848212690817704794983713768568912431388982883793878002287614711652531743087737814467999489</pre>

Can you find factors of that number?  I'll give you one answer.

<pre>36746043666799590428244633799627952632279158164343087642676032283815739666</pre>

and 

<pre>511279233373417143396810270092798736308917</pre>

Those numbers are dizzyingly large.  You could never work them out on a piece of paper, and neither could a computer.  There's no good way to write a computer program to find the factors of large numbers quickly.  The best you can do is discard the numbers that clearly don't work, and search for factors one by one among the trillions and trillions of numbers remaining.  Finding factors is NP-complete.  

I had to work hard to find factors, but making sure I'm right is easy.  You just copy and paste the second and third numbers into a computer and multiply them.  If they produce the first number, then I'm right and they are factors.  Your job is simple; this is a P-complete problem.

If finding those factors were easy, then the Internet would fall over.

<h2>P vs. NP</h2>

It's not very useful to have a secret if I can't prove I have it, but I can't just tell you the secret because then it wouldn't be a secret.  I need to prove I know the value without telling you what it is.  That's where the factors come in.  The larger first number proves I know the factors without ever telling you what those numbers were.  If you could come up with a way to quickly find large factors then you could steal my secrets.  Robert Redford starred in <a href="http://www.imdb.com/title/tt0105435/?ref_=fn_al_tt_1">a movie about this</a>.

Many smart people have been working on a way to find those factors, and they haven't found one yet.  We've based the entire security of the Internet on the "fact" that there's no easy way to find the factors of large numbers, but it isn't really a fact.  We don't know if a fast way to find factors or get directions for our salesman exists.  Maybe it's out there, and we just haven't found it yet.  Maybe someone will find it tomorrow.  That's what P vs. NP is all about.  

<h3>P &ne; NP</h3>

Right now we assume P doesn't equal NP.  That means some problems are easy and others are hard.  We think our secrets are safe, but we can't prove it.

Mathematics is based on a lot of assumptions.  Some of them last decades before they're proved true or false.  As long as the assumption that P doesn't equal NP remains true, then we can keep sharing secrets, email, and credit card numbers on the Internet without any problems.  If you proved that P does equal NP, then you could cause some big trouble.  

<h3>P = NP</h3>

Some people make the philosophical argument that P just can't equal NP.  If it did, then it would mean finding the solution to a problem was always as easy as verifying that the solution was correct.  Then anyone who could drive a car could build one, and anyone who could listen to a symphony could write one.  This makes my head hurt, but it's not the real problem.

If you could create a practical example of P equaling NP, then you could solve the traveling salesman problem and guess everyone's password.  And that's just the beginning.

A practical solution proving that P equals NP would give you enormous control over information everywhere.

<h2>What Comes Next</h2>

P vs. NP is one of the great unsolved problems in math and computer science, and it affects us every day.  It also asks a larger question about how we figure out the things we know.  Do we know them first and figure them out second, or do we need to work at a solution before we can find it?  If you can prove P vs. NP one way or the other, you'll <a href="http://en.wikipedia.org/wiki/Millennium_Prize_Problems#P_versus_NP">win a million dollars</a>.

For now we all sleep at night believing that P doesn't equal NP.  Our secrets are safe, and the world works the way we all think it does.  If it turned out that P does equal NP, it would be proof that we've all been trying to solve problems the wrong way.  
