Every line of my code comes out perfect the first time I write it.  Well... most of the time.  ...some of the time.  Hardly ever.

The truth is that I spend more of my time chasing down my own stupid programming errors than I'd like to admit.  That's why I use static analyzers on every JavaScript project I write.

Static analyzers look at your code and find issues before you run it.  They can do simple checks like enforce syntax (tabs instead of spaces), or more complex checks like making sure your code doesn't get too complex.  

When the projects get larger and team gets bigger you'll be happy to have a little help finding those <em>simple</em> bugs that turn out to be a lot less simple than they looked.

<h3>JSLint, JSHint, and the Closure Compiler</h3>

There are three main choices for static analyzers in the JavaScript world:  <a href="http://www.jslint.com/">JSLint</a>, <a hreaf="http://www.jshint.com/">JSHint</a>, and the <a hreaf="https://developers.google.com/closure/compiler/">Closure Compiler</a>.  

<h4>JSLint</h4>
JSLint was the first one and it's a simple static code analyzer.  You can run it on their website and it will find a lot of useful errors.  My big issue with JSLint is that it's rather rigid.  Here's a good example:

<pre><code class="language-javascript">
var s = 'mystring';
for (var i = 0; i < s.length; i++) {
    console.log(s.charAt(i));
}
</code></pre>

JSLint will show an error for this code claiming:

<pre>Move 'var' declarations to the top of the function.</pre>

The problem is declaring the variable <code>i</code> at the top of my loop.  It also doesn't like the use of the <code>++</code> operator at the end of the loop declaration.  JSLint wants the code to look like this:

<pre><code class="language-javascript">
var s = 'mystring';
var i;
for (i = 0; i < s.length; i = i + 1) {
    console.log(s.charAt(i));
}
</code></pre>

I appreciate where JSLint is coming from, but it's just too rigid for me.  It was too rigid for <a href="http://anton.kovalyov.net/">Anton Kovalyov</a> as well, so he created JSHint.

<h4>JSHint</h4>

JSHint works a lot like JSLint, but it's written using <a href="http://nodejs.org/">Node.js</a> and it's much more flexibile.  JSHint has a <a href="http://www.jshint.com/docs/options/">long list of options</a> and makes it possible to extend the checking by <a href="http://www.jshint.com/docs/reporters/">writing your own reporter</a>.  It's also easy to run JSHint on the command line of any machine with Node.js installed so it's easy to integrate it with your build.

<h4>Closure Compiler</h4>

The Closure Compiler from Google is a different breed.  It's written in Java and based on the <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/Rhino">Rhino</a> parser from Mozilla.  The Closure Compiler has a simple mode where it can do basic code checking, but it also has more advanced modes where it does extra checking and enforces special type declarations.

The Closure Compiler is also a compiler and not just a checker.  It will report errors about your JavaScript code, but it will also create a new minimzed version of your JavaScript which removes whitespace and comments as well as removing unused variable and simplyfing longer statements to make the resulting script as small as possible.

<h4>Choosing the right checker</h4>

My favorite is to combing the Closure Compiler with JSHint.  The two work well together and each covers some areas the other doesn't.  In addition I can use the extension capabilities of JSHint to write custom checkers.  A common checker I write is to check for specific functions I want to make sure people don't call.

This article with use JSHint for most of the examples, but the Closure Compiler would produce similar warnings.

<h3>== vs ===</h3>

JavaScript is a <a href="http://www.smashingmagazine.com/2013/04/18/introduction-to-programming-type-systems/">dynamically typed</a> langauge.  That means you don't have to declare types when you're coding, but they exist at runtime.  To deal with the dynamic nature of the runtime JavaScript offers two different compare operators:  <code>==</code> and <code>===</code>.  Let's look at an example.

<pre><code class="language-javascript">
    var nOne = 1;
    var sOne = '1';
    
    if (nOne == sOne) {
        alert('The two values were equal');
    }
    
    if (nOne === sOne) {
        alert('The two values were equal');
    }
</code></pre>

The <code>==</code> operator compares the two values of the objects.  This will convert the objects and compare them separately from their type.  The <code>===</code> operator compares the object types and the values.  In this case the first <code>if</code> block will pop up an alert and the second <code>if</code> block won't.  

The key is that you almost never want to use the <code>==</code>.  Comparing values separate from type is almost never the right thing.  In reality <code>1</code> is different from <code>'1'</code>.  These operators are easy to mistype and even easier to misread.  

Try to write this code with JSHint and you'll get:

<pre>test.js: line 9, col 12, Expected '===' and instead saw '=='.</pre>

<h3>Undefined and late definitions</h3>

Let's start with some simple code:

<pre><code class="language-javascript">
function test() {
    var myVar = 'Hello, World';
    console.log(myvar);
}
</code></pre>

See the bug?  I make this mistake all the time.  Run this code and you'll get an error:

<pre>ReferenceError: myvar is not defined
</pre>

Nows let's make the code a little more complicated:

<pre><code class="language-javascript">
function test() {
    myVar = 'Hello, World';
    console.log(myVar);
}
</code></pre>

Run this code and you'll get:

<pre>Hello, World</pre>

This code looks like it works and that's even worse.  The rules for declaring JavaScript variables and what scope they end up in are confusing at best.  

In the first case JSHint will tell you:

<pre>
    test.js: line 3, col 17, 'myvar' is not defined.
</pre>

and in the second case it will tell you:

<pre>
    test.js: line 2, col 5, 'myVar' is not defined.
    test.js: line 3, col 17, 'myVar' is not defined.
</pre>

The first case is saving you from a runtime bug.  You don't have to test your app, JSHint will just find the error.  The second case is worse.  Testing won't find this bug.

The problem with the second case is much worse.  The variable <code>myVar</code> has now escaped from the function and been <a href="http://www.adequatelygood.com/JavaScript-Scoping-and-Hoisting.html">hoisted</a> into the global namespace.  This means that it will exist and have a value of <code>Hello, World</code> after the <code>test</code> function is run.  This is called namespace polution.

The <code>myVar</code> variable will exist for every other function which is run after.  It hangs around like mold on your code causing insidious bugs you won't find until 3:00 AM the night before your release.  All because you forgot to type <code>var</code>.

<h3>Variable reuse</h3>

Redefining variables is allowed in JavaScript, but it's almost always an accident.  Take a look:

<pre><code class="language-javascript">
function incrementCount(counter) {
    if (counter.count) {
        counter.count++;
    } else {
        var counter = 1;
        counter.count = counter;
    }    
}
</code></pre>

In this function we increment the <code>count</code> property in the object which was passed in, but we need to add the property if it doesn't already exist.  See the bug?

This function will never add or increment a counter on anything.  The <code>else</code> statement will always be called and it will redefine the function argument variable <code>counter</code>.  Basically this function creates a new object, assigns a property to it, and never changes the object which was passed in.

This simple typo will make the code run without any errors and product a very strange result.  

JSHint will tell you:

<pre>
    test.js: line 21, col 21, 'counter' is already defined.
</pre>

<h3>Curly braces in blocks, loops, and conditionals</h3>

<pre><code class="language-javascript">
    if (false) 
        doSomethingElse();
        doSomething();
</code></pre>

Will this code <code>doSomething</code> or <code>doSomethingElse</code>?  At first glance I always think it will <code>doSomething</code> and <code>doSomethingElse</code>, but it won't.  This issue is just about code readbility.  If you can't understand what the code will do then you'll introduce bugs.  

Python and CoffeeScript like to skip the curly-braces.  It can work well in languages where you're gaurenteed that the whitespace will be well formatt, but JavaScript is looser than that.  JavaScript allows a lot of strange syntax, and using the curly-braces keeps you out of trouble.

<pre><code class="language-javascript">
    if (false) {
        doSomethingElse();
        doSomething();
    }
</code></pre>

Add the braces and you'll always make your code more readable.

<h3>Single and double quotes</h3>

<pre><code class="language-javascript">
    console.log("This is a string.  It's OK");
    console.log('This string is OK too.');
    console.log("This string " + 'is really not OK');
</code></pre>

JavaScript allows you to define strings with single and double quotes.  It's nice to have the flexibility at times, like when you're defining HTML, but the added flexibility can lead to some very difficult code.  

Google has a code style which always uses single quotes for strings so they don't have to escape apostrophe's.  I can't argue that single quotes are better than double quotes, but I can argue for consistency.  Keeping everything consistent helps code readability. 

It's easy to copy and paste or mistype a quote.  Once you have one bad quote others will follow.  Especially if you have a lot of people editing a file. Static analyzers will help you keep the quotes consistent and avoid a big clean up in the future.

<h3>Cyclomatic complexity</h3>

Cyclomatic complexity is the measure of how complex a give block of code is.  You look at the code and count the number of paths the code could possibly run.  That number is the cyclomatic complexity.

For example, this code has a cylcomatic complexity of one.

<pre><code class="language-javascript">
function main() {
    return 'Hello, World!';
}
</code></pre>

There's only one path you can follow through this code.

If we add a little conditional logic...

<pre><code class="language-javascript">
function main() {
    if (true) {
        return 'Hello, World!';
    } else {
        return 'Hello, unWorld!';
    }
}
</code></pre>

...the cyclomatic complexity jumps to two.

Ideal code is easy to read and understand.  The higher the cyclomatic complexity the more complex the code.  Everyone agrees that a high cyclomatic complexity is bad, but nobody agrees on where the limit is.  Five is fine, 100 is too high, but there's a lot of gray area in the middle.

I like to set my max cyclomatic complexity to 14, but I'll got a little higher for certain projects that do a lot of parsing.  

The real reason the complexity number is important is that it tells you when you need to refactor your code.  The first time you write a long function it always makes sense, but wait six months and come back to fix bugs and you'll be glad that you took the time to make is easier to read.

The big place cyclomatic breaks down is laundry lists.  I was working on a calendar once and I wanted to get the right first day of the week for each country.  I had a function that looked something like this:

<pre><code class="language-javascript">
function getFirstDay(country) {
    if (country === 'USA') {
        return 'Sunday';
    } else if (country === 'France') {
        return 'Monday';
    } else if...
}
</code></pre>

I supported a lot of countries and the cyclomatic complexity quickly grew to over 50.  This code was really easy to read, but the number was high and my code analysis tool complained.  In the end I split the function up so the complexity was below the max I was working with.  It's a little hacky, but it's a small price to pay for cleaner code.

<h3>When I don't do static checking</h3>

I started this article by stating that I always use code analysis tools, but there's one gi case where I don't:  prototypes.  I'll often put together quick prototypes to show interactive ideas and help my entire team come together on the way something should work.  Those prototypes are write once code.  I never need to fix bugs in them I throw them away a few weeks later.  Everything else gets code analysis.

Fixing these types of bugs at the beginning is easy, but finding them late the night before you release will drive you nuts.  Code analysis tools have saved my butt many times and they'll save yours as well.