You've presented the new site and everyone loves it.  The design is crisp, the code is bug-free, and you're ready to release.  Then someone asks, "Does it work in Japanese?"

You break out in a cold sweat:  you have no idea.  The site works in English and you figured other languages would come later.  Now you have to rework the whole app to support other languages.  Your release date slips, and you spend the next two months fixing bugs only to find you missed half of them.  

Localization makes your application ready to work in any language &mdash; and it's much easier if you do it from the beginning.  Just follow these 12 simple rules and you'll be ready to run anywhere in the world.

<h3>1. "Resource" all of your strings</h3>

The first step of localization is getting user-visible strings out of your code and into resource files.  Those strings include titles, product names, error messages, strings in images, and any other text the user might see.  

Most resource files work by giving each string a name and allowing you to specify different translation values for that string.  Many languages use properties files like this:

<pre>name = Username</pre>

or <a href="http://en.wikipedia.org/wiki/GNU_gettext">.pot files</a> like this:

<pre>msgid "Username"
msgstr "Nom d'utilisateur"</pre>

or <a href="http://en.wikipedia.org/wiki/Xliff">XLIFF</a> files like this:

<pre class="brush: xml">&lt;trans-unit id="1"&gt;
 &lt;source xml:lang="en"&gt;Username&lt;/source&gt;
 &lt;target xml:lang="fr"&gt;Nom d'utilisateur&lt;/target&gt;
&lt;/trans-unit&gt;
</pre>

The resource files are then loaded by a library which uses a combination of the language and country known as the <a href="http://en.wikipedia.org/wiki/Locale">locale</a> to identify the right string.  


Once you've placed your strings in external resource files, you can send them to translators and get back translated files for each locale your application supports.  

<h3>2. Never concatenate strings</h3>

Appending one string to another is almost always a localization bug.  It's easy to see this with modifiers like color.

Your stationery store shopping cart has items like pencils, pens, and sheets of paper.  Shoppers choose what they want and then select a color.  In the shopping cart you show them items like a red pencil or a blue pen with a function like this:

<pre class="brush: javascript">function getDescription() {
    var color = getColor();
    var item = getItem();

    return color + " " + item;
}
</pre>
 
This code works well in English where the color comes first, but it breaks in French where <em>red pencil</em> is <em>crayon rouge</em> and <em>blue pen</em> is <em>stylo &#224; encre bleue</em>.  French speakers put modifier words after the items they modify (and they aren't the only ones).  The <code>getDescription</code> function can never support languages like this with simple string concatenation.

The solution is to specify parametrized strings which change the order of the item and color for each language.  Define a resourced string that looks like this:

<pre>itemDescription = {0} {1}</pre>

It might not look like much, but this string makes the translation possible.  We can use it in a new <code>getDescription</code> function like this:

<pre class="brush: javascript">function getDescription() {
    var color = getColor();
    var item = getItem();

    return getLocalizedString('itemDescription', color, item);
}
</pre>

Now your translators can easily switch the order like this:

<pre>itemDescription = {1} {0}</pre>

The <code>getLocalizedString</code> function here takes the name of a resource string ("itemDescription") and some additional parameters (color and item) to substitute for placeholders in the resource string.  Most programming languages provide a function similar to <code>getLocalizedString</code>.  (The one notable exception is JavaScript, but we'll talk more about that later.)

This method also works for strings with text in them like:

<pre>invalidUser = The username {0} is already taken. Please choose another one.</pre>

<h3>3. Put all of your punctuation in the resourced string</h3>

It's often tempting to tack punctuation on later, so you can reuse the same string in a label where it needs a colon and in a tooltip where it doesn't.  But this is another example of bad string concatenation.  

Here you're adding a simple login form using PHP in a WordPress environment:

<pre class="brush: php">&lt;form&gt;
&lt;p&gt;Username: &lt;input type="text" name="username"&gt;&lt;/p&gt;
&lt;p&gt;Password: &lt;input type="text" name="password"&gt;&lt;/p&gt;
&lt;/form&gt;
</pre>

You want to make sure the form works in other languages so you add the strings for localization.  WordPress makes this easy with a function named <a href="http://codex.wordpress.org/Function_Reference/_2"><code>__</code></a> (underscore underscore):

<pre class="brush: php">&lt;form&gt;
&lt;p&gt;&lt;?php echo(__('Username', 'my-plugin') ?&gt;: &lt;input type="text" name="username"&gt;&lt;/p&gt;
&lt;p&gt;&lt;?php echo(__('Password', 'my-plugin') ?&gt;: &lt;input type="text" name="password"&gt;&lt;/p&gt;
&lt;/form&gt;
</pre>

Spot the bug?  This is another case of string concatenation.  The colon after the labels isn't localized.  This will look wrong in languages like French and Russian which always put spaces around colons.  Punctuation is part of the string and belongs in the resource file.

<pre class="brush: php">&lt;form&gt;
&lt;p&gt;&lt;?php echo(__('Username:', 'my-plugin') ?&gt; &lt;input type="text" name="username"&gt;&lt;/p&gt;
&lt;p&gt;&lt;?php echo(__('Password:', 'my-plugin') ?&gt; &lt;input type="text" name="password"&gt;&lt;/p&gt;
&lt;/form&gt;
</pre>

Now the form can use <em>Username:</em> in English and <em>Nom d'utilisateur :</em> in French.

<h3>4. Remember that "first names" sometimes aren't</h3>

My name is Zack Grossbart.  Zack is my given or first name, and Grossbart is my last or family name.  Everyone in my family is named Grossbart, but I'm the only Zack.  

In English-speaking countries the first name is the given name and the last name is the family name.  Most Asian countries go the other way.

The cellist Yo-Yo Ma is a member of the Ma family.  In Chinese he writes his family name first:  Ma Yo-Yo (馬友友).  

This issue gets tricky because many people change their names when moving from Asian countries to English-speaking ones.  They often switch the order to fit in with other customs, so you can't make any assumptions.  

You must provide a way to customize the display of names; you can't assume that first name always comes first or the last name always comes last.

WordPress handles this pretty well by prompting you for how you want your name to show up.

<img src="http://mcoding.smashingmagazine.com/wp-content/uploads/2012/07/name_format2.png" alt="Name formatting in WordPress" title="Name formatting in WordPress" width="547" height="232" class="aligncenter size-full wp-image-120598" />
        
It would be even better if they supported a middle name and a way to specify the format per locale so you could make your name one way in English and another in Chinese, but nobody's perfect.

<h3>5. Never hard-code date, time, or currency formats</h3>

The whole world is inconsistent about date and time formats.  Some people put the month first (6/21/2012), others the day of the month (21/6/2012).  Some use 24-hour (14:00) time and some use 12 (2:00 PM).  Taiwan uses specially translated strings instead of AM and PM and those come first (上午 2:00).  

Your best bet is to store all dates and times in a standard format like <a href="http://en.wikipedia.org/wiki/ISO_time">ISO time</a> or <a href="http://en.wikipedia.org/wiki/Epoch_time">epoch time</a>, and use a library like <a href="http://datejs.com/">date.js</a> or <a href="http://momentjs.com/">moment.js</a> to format them for the current locale.  These libraries can also handle converting the time to the current time zone, so you can store all dates and times in a common format on the server (like <a href="http://en.wikipedia.org/wiki/UTC">UTC</a>) and convert them to the right time zone in the browser.

Dates and times are also tricky when displaying calendars and date pickers.  Estonia starts the week on Saturday, the United States starts on Sunday, the United Kingdom on Monday, and the Maldives on Friday.  The <a href="http://jqueryui.com/demos/datepicker/#localization">jQuery UI date picker</a> includes over 50 localized files to support different calendar formats around the world. 

The same is true for currencies and other number formats.  Some countries use commas to separate numbers and others use periods.  Always use a library with localized files for each of the locales you need to support.

<h3>6. Use UTF-8 almost every time</h3>

The history of computer character encodings is a <a href="http://coding.smashingmagazine.com/2012/06/06/all-about-unicode-utf8-character-sets/">long story</a>, but the most important thing to remember is that <a href="http://en.wikipedia.org/wiki/UTF-8">UTF-8</a> is the right choice 99 percent of the time.  The only time not to use UTF-8 is when you're working primarily with Asian languages and absolutely need the efficiency of <a href="http://en.wikipedia.org/wiki/Utf-16">UTF-16</a>.

This comes up a lot with Web applications.  If the browser and the server don't use the same character encoding, then the characters get corrupted and your application fills up with little squares and question marks.  

Many programming languages store files using the system default encoding, but it doesn't matter that your server is English when all of your users are browsing in Chinese.  UTF-8 fixes that by standardizing the encodings across the browser and the server.

Use UTF-8 at the top of all your HTML pages:

<pre class="brush: html">&lt;head&gt;
    &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;</pre>

The <a href="http://www.ietf.org/rfc/rfc4627.txt">JSON specification</a> requires that all JSON documents use Unicode with a default of UTF-8, so make sure to use UTF-8 whenever you're reading or writing data.

<h3>7. Give strings room to grow and shrink</h3>

Strings change size in translation.

<img src="http://mcoding.smashingmagazine.com/wp-content/uploads/2012/06/repeat_password.png" alt="Repeat password example" title="Repeat password example" width="500" height="136" class="aligncenter size-full wp-image-120596" />
        
<em>Repeat password</em> is over 50 percent wider in German than it is in English; if there isn't enough space, your strings will overlap other controls.  WordPress solves this problem by leaving extra space after each label for the string to grow.

<img src="http://mcoding.smashingmagazine.com/wp-content/uploads/2012/07/label_spacing.png" alt="Label spacing in the WordPress admin" title="Label spacing in the WordPress admin" width="551" height="80" class="aligncenter size-full wp-image-120834" />

That works well for languages with strings that are roughly the same length, but languages with longer words like German and Finnish will still overlap controls if you don't leave enough space.  You can add more space, but that makes more compact languages like Chinese hard to use since the labels and controls are pretty far apart.

<img src="http://mcoding.smashingmagazine.com/wp-content/uploads/2012/07/label_spacing_ch.png" alt="Label spacing in the WordPress admin in Chinese" title="Label spacing in the WordPress admin in Chinese" width="551" height="80" class="aligncenter size-full wp-image-120835" />

Many forms give their labels more room to grow and shrink by aligning them to the right or placing them above the controls.

<img src="http://mcoding.smashingmagazine.com/wp-content/uploads/2012/07/labels_above.png" alt="Label above controls in the WordPress admin" title="Label above controls in the WordPress admin" width="551" height="121" class="aligncenter size-full wp-image-120836" />

Labels above the controls work well for shorter forms, but they make your form very tall if you have a lot of fields.

There's no perfect answer for how to make your application work in all languages; many forms mix and match these approaches.  Short labels like <em>Username</em> or <em>Role</em> won't change that much in translation and just need a little extra space.  Longer paragraphs will change substantially and need room to grow wider, taller or sometimes both.

<img src="http://mcoding.smashingmagazine.com/wp-content/uploads/2012/07/long_short_label.png" alt="Label next to and above controls in the WordPress admin" title="Label next to and above controls in the WordPress admin" width="547" height="163" class="aligncenter size-full wp-image-120837" />

Here WordPress gives a little extra space for the <em>Biographical Info</em> label, but puts the longer description below the field so it can grow in translation.

<h3>8. Always use a full locale</h3>

The full locale includes the language and country code and supports alternate spellings, date formats, and other differences between two countries with a shared language.  

Always use a full locale instead of just a language when translating, so you know whether you're doing someone a favor or a favour, they should take the elevator or the lift, or &pound;100,00 is expensive or not.

<h3>9. Never trust the browser to know the right locale</h3>

Localization is much more difficult with browsers and JavaScript because they give a different locale depending on who's asking.

JavaScript includes a property to tell you the current language named <a href="http://www.w3schools.com/jsref/prop_nav_userlanguage.asp"><code>navigator.userLanguage</code></a>.  All browsers support it, but it's generally useless.

If I install Firefox in English then my <code>navigator.userLanguage</code> value will say <code>English</code>.  I can then go into my preferences and change my preferred languages.  Firefox lets me select multiple languages so I can say that I would prefer English from the US, then I would take any other English, and I would settle for Japanese after that.  

<img src="http://mcoding.smashingmagazine.com/wp-content/uploads/2012/06/languages.png" alt="Language preferences in Firefox" title="Language preferences in Firefox" width="457" height="369" class="aligncenter size-full wp-image-120597" />
        
Specifying a set of locales makes it possible for servers to find the best match between the languages that I know they support.  Firefox takes these locales and sends them to the server in an HTTP header like this:

<pre>Accept   en-us,en;q=0.7,ja;q=0.3</pre>

Firefox even uses the quality factor (that <code>q=</code> part) to indicate how much I prefer one locale over another.

This means the server might return content in English, Japanese, or another language if it doesn't support either.  However, even after I set my preferred language in Firefox the value of my <code>navigator.userLanguage</code> property will still be English and only English.  The other browsers don't do much better.  That means I might end up with the server thinking I want Japanese and the JavaScript thinking I want English.  

JavaScript has never solved this problem and there is not one standard localization library for JavaScript, but dozens of different standards.  The best solution is to embed a JavaScript property or some other field in your page indicating the locale when the server processes each request.  Then you can use that locale when formatting any strings, dates, or numbers from JavaScript.

<h3>10. Plan for languages that read left to right and right to left</h3>

Most languages are written on screen from left to right, but Arabic, Hebrew and plenty of others go from right to left.  HTML provides a property on the <code>html</code> element called <code>dir</code> which indicates if the page is <code>ltr</code> (left to right) or <code>rtl</code> (right to left).  

<pre class="brush: html">&lt;html dir="rtl"&gt;</pre>

There's also a direction property in CSS:

<pre class="brush: css">input {
    direction: rtl;
}</pre>

Setting the direction property will make the page work for the standard HTML tags, but it can't switch a CSS element with <code>float: left;</code> to <code>float: right;</code> or change your absolute layout.  To make more complex layouts work you need a new stylesheet.

An easy way to determine the direction of the current language is to include a direction string in the resourced strings.

<pre>direction = rtl</pre>

Then you can use that string to load a different style sheet based on the current locale.  

<h3>11. Never sort on the browser</h3>

JavaScript provides a <a href="http://www.w3schools.com/jsref/jsref_sort.asp"><code>sort</code></a> function that can arrange lists of strings alphabetically.  It works by comparing each character in each string to tell if <em>a</em> is greater than <em>b</em> or <em>y</em> is less than <em>z</em>.  That's why it makes 40 come before 5.

The browser knows that <em>y</em> comes before <em>z</em> by using a large mapping table for each character.  However, the browser only includes the mapping tables in the current locale.  That means if you have a list of Japanese names, the browser can't sort them properly in an English locale; it will just sort them by Unicode value, which isn't correct.

This problem is easy to see in languages like Polish and Vietnamese which frequently use diacritical marks.  The browser can tell that <em>a</em> comes before <em>b</em>, but doesn't know if <em>ằ</em> comes before <em>ã</em>.

The only place to sort strings properly is on the server.  Make sure the server has all the code mappings for the languages you support, send lists to the browser presorted, and call the server whenever you want to change the sorting.  Also make sure the server is taking locale into account for sorting, including right-to-left locales.

<h3>12. Test early and often</h3>

Most projects don't worry about localization until it's too late.  A big customer in Asia complains that the site doesn't work and everyone scrambles to fix 100 little localization bugs they've never thought of.  Following the rules in this article will avoid many of those problems, but you still need to test and translations usually aren't ready until the end of the project.

I used to translate my projects into <a href="http://en.wikipedia.org/wiki/Pig_Latin">Pig Latin</a>, but that didn't test Asian characters and most browsers don't support it.  Now I create a test translation with <a href="http://en.wikipedia.org/wiki/Xhosa_language">Xhosa</a> (<code>xh_ZA</code>).  All browsers support Xhosa, Nelson Mandela speaks it natively, but I've never been asked to support it in a product.
  
I don't speak Xhosa, so I create a new translation file and add <code>xh</code> to the beginning and end of every string.  The <code>xh</code> makes it easy to see if I've missed a string in the code.  Throw in a few Japanese Kanji characters to test character encoding and I have a messy string that tests for all my translation issues.

Making the test translation file is easy.  Just save a new properties file with <code>xh_ZA</code> in the file name and turn

<pre>name = Username</pre>

into 

<pre>name = xh吳清源Username吳清源xh</pre>

The resulting jumble tests to make sure that I've resourced every string, I'm using the right locale, my forms work with longer strings, and I'm using the right character set.  I just quickly scan the application for anything without the <code>xh</code> and fix my bugs before they become urgent issues.

Do the right thing for localization ahead of time, and you'll save a lot of trouble in the long run.
